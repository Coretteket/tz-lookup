var fs           = require("fs"),
    zlib         = require("zlib"),
    data         = fs.readFileSync("tz.bin"),
    tiles_across = data.readUInt16LE( 0),
    tiles_down   = data.readUInt16LE( 2),
    tile_width   = data.readUInt16LE( 4),
    tile_height  = data.readUInt16LE( 6),
    tz_count     = data.readUInt16LE( 8),
    tz_width     = data.readUInt16LE(10),
    index_len    = (tiles_across * tiles_down) << 2,
    tz_len       = tz_count * tz_width,
    header       = data.slice(0, 12),
    index        = data.slice(12, 12 + index_len),
    tzdata       = data.slice(12 + index_len, 12 + index_len + tz_len),
    tzs          = [],
    tz_str_len   = 0,
    chunkdata    = data.slice(12 + index_len + tz_len),
    chunks       = [],
    new_chunk_len = 0,
    map          = new Buffer(tiles_across * tiles_down * 2),
    i            = -4;

function tz() {
  var i, start, len;

  for(i = 0; i < tz_count; i++) {
    start = i * tz_width;
    for(len = 0; len < tz_width && tzdata[start + len]; len++);
    tzs.push(tzdata.slice(start, start + len));
    tz_str_len += len;
  }
}

function finish() {
  var head = new Buffer(10),
      chunklist = new Buffer(chunks.length * 4),
      tzlist = new Buffer(tzs.length * 4),
      payload_off = head.length + map.length + chunklist.length + tzlist.length,
      off = 0,
      i;

  /* HEADER */
  head.writeUInt16LE(tiles_across, 0);
  head.writeUInt16LE(tiles_down, 2);
  head.writeUInt8(tile_width, 4);
  head.writeUInt8(tile_height, 5);
  head.writeUInt16LE(chunks.length, 6);
  head.writeUInt16LE(tz_count, 8);
  process.stdout.write(head);

  /* MAP */
  process.stdout.write(map);

  /* CHUNKLIST */
  for(i = 0; i < chunks.length; i++) {
    if(chunks[i].length >= 1024)
      throw new Error("yipe!");

    chunklist.writeUInt32LE(
      (off << 10) | (chunks[i].length & 1023),
      i << 2
    );
    off += chunks[i].length;
  }
  process.stdout.write(chunklist);

  /* TZLIST */
  for(i = 0; i < tzs.length; i++) {
    tzlist.writeUInt32LE(
      (off << 10) | (tzs[i].length & 1023),
      i << 2
    );
    off += tzs[i].length;
  }
  process.stdout.write(tzlist);

  /* CHUNKS */
  for(i = 0; i < chunks.length; i++)
    process.stdout.write(chunks[i]);

  /* TZ STRINGS */
  for(i = 0; i < tzs.length; i++)
    process.stdout.write(tzs[i]);
}

function next() {
  i += 4;
  if(i === index_len) {
    finish();
    return;
  }

  var data = index.readUInt32LE(i),
      off  = data >>> 12,
      len  = data & 4095;

  if(off === 0xFFFFF) {
    map.writeUInt16LE((len & 0x01FF) | 0xFE00, i >> 1);
    setImmediate(next);
    return;
  }

  map.writeUInt16LE(chunks.length, i >> 1);
  zlib.inflate(chunkdata.slice(off, off + len), function(err, data) {
    if(err)
      throw err;

    var pixels = tile_width * tile_height,
        count = [],
        i, t, bpp;

    for(i = 0; i < pixels; i++) {
      t = data.readUInt16LE(i << 1);
      if(!~count.indexOf(t))
        count.push(t);
    }

    count.sort(function(a, b) { return a - b; });

    if(count.length <= 1)
      throw new Error("yipe");

    else if(count.length <= 2)
      bpp = 1;

    else if(count.length <= 4)
      bpp = 2;

    else if(count.length <= 16)
      bpp = 4;

    else if(count.length <= 256)
      bpp = 8;

    else
      throw new Error("yipe");

    var head = new Buffer(1 + count.length * 2),
        buf  = new Buffer(Math.ceil(tile_width * tile_height * bpp / 8)),
        off, i;

    off = 0;

    head.writeUInt8(count.length, off);
    off += 1;

    for(i = 0; i < count.length; i++) {
      head.writeUInt16LE(count[i], off);
      off += 2;
    }

    off = 0;

    if(bpp === 1)
      for(i = 0; i < pixels; i += 8) {
        buf.writeUInt8(
          (count.indexOf(data.readUInt16LE((i + 0) << 1)) << 0) |
          (count.indexOf(data.readUInt16LE((i + 1) << 1)) << 1) |
          (count.indexOf(data.readUInt16LE((i + 2) << 1)) << 2) |
          (count.indexOf(data.readUInt16LE((i + 3) << 1)) << 3) |
          (count.indexOf(data.readUInt16LE((i + 4) << 1)) << 4) |
          (count.indexOf(data.readUInt16LE((i + 5) << 1)) << 5) |
          (count.indexOf(data.readUInt16LE((i + 6) << 1)) << 6) |
          (count.indexOf(data.readUInt16LE((i + 7) << 1)) << 7),
          off
        );
        off += 1;
      }

    else if(bpp === 2)
      for(i = 0; i < pixels; i += 4) {
        buf.writeUInt8(
          (count.indexOf(data.readUInt16LE((i + 0) << 1)) << 0) |
          (count.indexOf(data.readUInt16LE((i + 1) << 1)) << 2) |
          (count.indexOf(data.readUInt16LE((i + 2) << 1)) << 4) |
          (count.indexOf(data.readUInt16LE((i + 3) << 1)) << 6),
          off
        );
        off += 1;
      }

    else if(bpp === 4)
      for(i = 0; i < pixels; i += 2) {
        buf.writeUInt8(
          (count.indexOf(data.readUInt16LE((i + 0) << 1)) << 0) |
          (count.indexOf(data.readUInt16LE((i + 1) << 1)) << 4),
          off
        );
        off += 1;
      }

    else if(bpp === 8)
      for(i = 0; i < pixels; i++) {
        buf.writeUInt8(
          count.indexOf(data.readUInt16LE(i << 1)),
          off
        );
        off += 1;
      }

    zlib.deflateRaw(buf, function(err, comp) {
      if(err)
        throw err;

      comp = Buffer.concat([head, comp]);

      chunks.push(comp);
      new_chunk_len += comp.length;

      next();
    });
  });
}

tz();
next();

/* HEADER:
 * tiles_across - short
 * tiles_down - short
 * tile_width - byte
 * tile_height - byte
 * chunk_count - short
 * tz_count - short

 * INDEXES:
 *   MAP (tiles_across * tiles_down * short)
 *   CHUNKLIST (chunk_count * int)
 *   TZLIST (tz_count * int)

 * TILE CHUNK DATA

 * TIMEZONE STRING DATA */
