#!/usr/bin/env node

var fs   = require("fs"),
    path = require("path"),
    MAX_DISTANCE_SQ = 0.16,
    TILE_WIDTH      = 8,
    TILE_HEIGHT     = 8,
    MAX_DEPTH       = 3;

function bound(poly) {
  var bound = [
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY
      ],
      i;

  for(i = poly.length; i--; ) {
    if(poly[i][0] < bound[0]) bound[0] = poly[i][0];
    if(poly[i][0] > bound[2]) bound[2] = poly[i][0];
    if(poly[i][1] < bound[1]) bound[1] = poly[i][1];
    if(poly[i][1] > bound[3]) bound[3] = poly[i][1];
  }

  return bound;
}

function area(poly) {
  var area = 0.0,
      a = poly[0],
      i, b;

  for(i = poly.length; i--; ) {
    b = a;
    a = poly[i];
    area += a[0] * b[1] - a[1] * b[0];
  }

  return Math.abs(area * 0.5);
}

function contains(polygon, lat, lon) {
  var a = polygon[0],
      t = false,
      i, b;

  for(i = polygon.length; i--; ) {
    b = a;
    a = polygon[i];

    if(((a[1] <= lat && lat < b[1]) || (b[1] <= lat && lat < a[1])) && ((lon - a[0]) < ((b[0] - a[0]) * (lat - a[1]) / (b[1] - a[1]))))
      t = !t;
  }

  return t;
}

/* This actually returns the distance squared. :p */
function line(lat, lon, a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      u;

  if(x === 0.0 && y === 0.0) {
    x = a[0];
    y = a[1];
  }

  else {
    u = ((lon - a[0]) * x + (lat - a[1]) * y) / (x * x + y * y);

    if(u <= 0.0) {
      x = a[0];
      y = a[1];
    }

    else if(u >= 1.0) {
      x = b[0];
      y = b[1];
    }

    else {
      x = a[0] + u * x;
      y = a[1] + u * y;
    }
  }

  x -= lon;
  y -= lat;
  return x * x + y * y;
}

function distance(lat, lon, polygon) {
  var distance = Number.POSITIVE_INFINITY,
      a = polygon[0],
      b, i, t;

  for(i = polygon.length; i--; ) {
    b = a;
    a = polygon[i];
    t = line(lat, lon, a, b);

    if(t < distance)
      distance = t;
  }

  return distance;
}

function Polygon(feature) {
  this.tzid = feature.properties.TZID;
  this.data = feature.geometry.coordinates;
  this.__boundingBox();
  this.__area();
}

Polygon.prototype = {
  __boundingBox: function() {
    this.box = bound(this.data[0]);
  },
  __area: function() {
    var i;

    this.area = area(this.data[0]);
    for(i = this.data.length; --i; )
      this.area -= area(this.data[i]);
  },
  overlap: function(that_box) {
    return this.box[0] <= that_box[2] && this.box[1] <= that_box[3] &&
           this.box[2] >= that_box[0] && this.box[3] >= that_box[1];
  },
  distance: function(lat, lon) {
    var i;

    /* Outside polygon: return distance to the edge. */
    if(!contains(this.data[0], lat, lon))
      return distance(lat, lon, this.data[0]);

    /* Inside polygon hole: return distance to hole's edge. */
    for(i = this.data.length; --i; )
      if(contains(this.data[i], lat, lon))
        return distance(lat, lon, this.data[i]);

    /* Inside polygon but outside all holes. */
    return 0.0;    
  }
};

function readGeoJSON(pathname, callback) {
  fs.readFile(pathname, "ascii", function(err, data) {
    var i;

    if(err) {
      callback(err, null);
      return;
    }

    try {
      data = JSON.parse(data.toString("ascii"));
    }

    catch(err) {
      callback(err, null);
      return;
    }

    data = data.features;
    for(i = data.length; i--; )
      if(!data[i].properties ||
         !data[i].properties.TZID ||
         data[i].properties.TZID === "uninhabited")
        data.splice(i, 1);

      else
        data[i] = new Polygon(data[i]);

    data.sort(function(a, b) {
      return a.area - b.area;
    });

    callback(null, data);
  });
}

function tzindex(polygons) {
  var hash = {},
      list = [],
      i;

  for(i = polygons.length; i--; )
    hash[polygons[i].tzid] = -1;

  for(i in hash)
    if(hash.hasOwnProperty(i))
      list.push(i);

  list.sort();

  for(i = list.length; i--; )
    hash[list[i]] = i;

  return {list: list, hash: hash};
}

function indent(n) {
  var str = "";

  while(n--)
    str += "  ";

  return str;
}

console.warn("WIDTH = %d, HEIGHT = %d", Math.pow(TILE_WIDTH, MAX_DEPTH), Math.pow(TILE_HEIGHT, MAX_DEPTH));
readGeoJSON(path.join(__dirname, "tz_world.json"), function(err, polygons) {
  if(err)
    throw err;

  var zones = tzindex(polygons),
      tiles = [];

  function tile(polygons, min_lat, min_lon, max_lat, max_lon, depth) {
    var box = [
          min_lon - MAX_DISTANCE_SQ,
          min_lat - MAX_DISTANCE_SQ,
          max_lon + MAX_DISTANCE_SQ,
          max_lat + MAX_DISTANCE_SQ
        ],
        list = [], i, data, x, y, lat, lon, best, dist, t;

    for(i = polygons.length; i--; )
      if(polygons[i].overlap(box))
        list.push(polygons[i]);

    /* No polygons cover the area? Well then, just exit early. */
    if(list.length === 0) {
      console.warn("%s[%d,%d,%d,%d] => empty (no coverage)", indent(depth), min_lat, min_lon, max_lat, max_lon);
      return 0xFFFF;
    }

    /* If we don't want to recurse any more, just return a single pixel. */
    if(depth === MAX_DEPTH) {
      lat = (min_lat + max_lat) * 0.5;
      lon = (min_lon + max_lon) * 0.5;

      best = null;
      dist = MAX_DISTANCE_SQ;
      for(i = list.length; i--; ) {
        box[0] = lon - dist;
        box[1] = lat - dist;
        box[2] = lon + dist;
        box[3] = lat + dist;
        if(!list[i].overlap(box))
          continue;

        t = list[i].distance(lat, lon);
        if(t >= dist)
          continue;

        best = list[i];
        dist = t;
      }

      if(!best) {
        console.warn("%s[%d,%d,%d,%d] => empty (max depth)", indent(depth), min_lat, min_lon, max_lat, max_lon);
        return 0xFFFF;
      }

      console.warn("%s[%d,%d,%d,%d] => %s (max depth)", indent(depth), min_lat, min_lon, max_lat, max_lon, best.tzid);
      return (zones.hash[best.tzid] & 0x01FF) | 0xFE00;
    }

    /* Look up the entire tile. */
    data = new Buffer((TILE_WIDTH * TILE_HEIGHT) << 1);
    lat = (max_lat - min_lat) / TILE_HEIGHT;
    lon = (max_lon - min_lon) / TILE_WIDTH;
    for(y = TILE_HEIGHT; y--; )
      for(x = TILE_WIDTH; x--; )
        data.writeUInt16LE(
          tile(list, min_lat + y * lat, min_lon + x * lon, min_lat + (y + 1) * lat, min_lon + (x + 1) * lon, depth + 1),
          (y * TILE_WIDTH + x) << 1
        );

    /* If the tile only contains a single timezone, return that time zone. */
    for(i = TILE_WIDTH * TILE_HEIGHT; i--; ) {
      /* If this tile recurses down, then it *definitely* doesn't contain a
       * single timezone. */
      if(data.readUInt16LE(i << 1) < 0xFE00)
        break;

      /* If this pixel doesn't match the top-left-most pixel, then this tile
       * doesn't contain a single timezone. */
      if(data.readUInt16LE(i << 1) !== data.readUInt16LE(0))
        break;
    }

    /* If we didn't bail early, then all the pixels in this tile match. Return
     * one. */
    if(i === -1) {
      console.warn("%s[%d,%d,%d,%d] => %s (all equal)", indent(depth), min_lat, min_lon, max_lat, max_lon, data.readUInt16LE(0) === 0xFFFF ? "empty" : zones.list[data.readUInt16LE(0) & 0x01FF]);
      return data.readUInt16LE(0);
    }

    /* FIXME: We can be clever: if we're far enough down the tree, and either
     * A) the tile consists of international waters and only one zone, or B)
     * the tile consists overwhelmingly of one zone, then return the relevant
     * zone. */

    /* Otherwise, push the tile and return it's ID. */
    if(tiles.length >= 0xFE00)
      throw new Error("Too many tiles! Increase the tile resolution or decrease the max depth.");

    console.warn("%s[%d,%d,%d,%d] => new tile", indent(depth), min_lat, min_lon, max_lat, max_lon);
    tiles.push(data);
    return tiles.length - 1;
  }

  console.warn("TIMEZONE_LIST = %j", zones.list);
  tile(polygons, -90.0, -180.0, +90.0, +180.0, 0);

  console.warn("TILE_COUNT = %d, FILE_LENGTH = %d", tiles.length, tiles.length * TILE_WIDTH * TILE_HEIGHT * 2);
  process.stdout.write(Buffer.concat(tiles));
});
