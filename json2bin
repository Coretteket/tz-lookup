#!/usr/bin/env node

var fs   = require("fs"),
    path = require("path"),
    SIZE            = 2,
    MAX_DEPTH       = 12,
    MAX_DISTANCE_SQ = 0.16;

function bound(poly) {
  var bound = [
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY
      ],
      i;

  for(i = poly.length; i--; ) {
    if(poly[i][0] < bound[0]) bound[0] = poly[i][0];
    if(poly[i][0] > bound[2]) bound[2] = poly[i][0];
    if(poly[i][1] < bound[1]) bound[1] = poly[i][1];
    if(poly[i][1] > bound[3]) bound[3] = poly[i][1];
  }

  return bound;
}

function area(poly) {
  var area = 0.0,
      a = poly[0],
      i, b;

  for(i = poly.length; i--; ) {
    b = a;
    a = poly[i];
    area += a[0] * b[1] - a[1] * b[0];
  }

  return Math.abs(area * 0.5);
}

function contains(polygon, lat, lon) {
  var a = polygon[0],
      t = false,
      i, b;

  for(i = polygon.length; i--; ) {
    b = a;
    a = polygon[i];

    if(((a[1] <= lat && lat < b[1]) || (b[1] <= lat && lat < a[1])) && ((lon - a[0]) < ((b[0] - a[0]) * (lat - a[1]) / (b[1] - a[1]))))
      t = !t;
  }

  return t;
}

/* This actually returns the distance squared. :p */
function line(lat, lon, a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      u;

  if(x === 0.0 && y === 0.0) {
    x = a[0];
    y = a[1];
  }

  else {
    u = ((lon - a[0]) * x + (lat - a[1]) * y) / (x * x + y * y);

    if(u <= 0.0) {
      x = a[0];
      y = a[1];
    }

    else if(u >= 1.0) {
      x = b[0];
      y = b[1];
    }

    else {
      x = a[0] + u * x;
      y = a[1] + u * y;
    }
  }

  x -= lon;
  y -= lat;
  return x * x + y * y;
}

function distance(lat, lon, polygon) {
  var distance = Number.POSITIVE_INFINITY,
      a = polygon[0],
      b, i, t;

  for(i = polygon.length; i--; ) {
    b = a;
    a = polygon[i];
    t = line(lat, lon, a, b);

    if(t < distance)
      distance = t;
  }

  return distance;
}

function Polygon(feature) {
  this.tzid = feature.properties.TZID;
  this.data = feature.geometry.coordinates;
  this.__boundingBox();
  this.__area();
}

Polygon.prototype = {
  __boundingBox: function() {
    this.box = bound(this.data[0]);
  },
  __area: function() {
    var i;

    this.area = area(this.data[0]);
    for(i = this.data.length; --i; )
      this.area -= area(this.data[i]);
  },
  overlap: function(that_box) {
    return this.box[0] <= that_box[2] && this.box[1] <= that_box[3] &&
           this.box[2] >= that_box[0] && this.box[3] >= that_box[1];
  },
  distance: function(lat, lon) {
    var i;

    /* Outside polygon: return distance to the edge. */
    if(!contains(this.data[0], lat, lon))
      return distance(lat, lon, this.data[0]);

    /* Inside polygon hole: return distance to hole's edge. */
    for(i = this.data.length; --i; )
      if(contains(this.data[i], lat, lon))
        return distance(lat, lon, this.data[i]);

    /* Inside polygon but outside all holes. */
    return 0.0;    
  }
};

function readGeoJSON(pathname, callback) {
  fs.readFile(pathname, "ascii", function(err, data) {
    var i;

    if(err) {
      callback(err, null);
      return;
    }

    try {
      data = JSON.parse(data.toString("ascii"));
    }

    catch(err) {
      callback(err, null);
      return;
    }

    data = data.features;
    for(i = data.length; i--; )
      if(!data[i].properties ||
         !data[i].properties.TZID ||
         data[i].properties.TZID === "uninhabited")
        data.splice(i, 1);

      else
        data[i] = new Polygon(data[i]);

    data.sort(function(a, b) {
      return a.area - b.area;
    });

    callback(null, data);
  });
}

function tzindex(polygons) {
  var hash = {},
      list = [],
      i;

  for(i = polygons.length; i--; )
    hash[polygons[i].tzid] = -1;

  for(i in hash)
    if(hash.hasOwnProperty(i))
      list.push(i);

  list.sort();

  for(i = list.length; i--; )
    hash[list[i]] = i;

  return {list: list, hash: hash};
}

function write(root) {
  var queue = [],
      nodes = [],
      node, i, data, t, j;

  for(queue.push(root); node = queue.shift(); ) {
    node.id = nodes.length;
    nodes.push(node);

    for(i = 0; i < node.data.length; i++)
      if(typeof node.data[i] !== "number")
        queue.push(node.data[i]);
  }

  if(nodes.length >= 0x10000)
    throw new Error("too many tiles to fit in a short, sorry.");

  data = new Buffer((nodes.length * SIZE * SIZE) << 1);

  console.warn("TILE_COUNT = %d, BYTE_LENGTH = %d", nodes.length, data.length);
  
  for(i = nodes.length; i--; ) {
    node = nodes[i];

    for(j = node.data.length; j--; ) {
      if(typeof node.data[j] === "number")
        t = node.data[j];

      else {
        t = node.data[j].id - node.id;

        if(t < 0 || (t & 0xFE00) === 0xFE00)
          throw new Error("too many tiles, sorry.");
      }

      data.writeUInt16BE(t, (node.id * SIZE * SIZE + j) << 1);
    }
  }

  process.stdout.write(data);
}

console.warn("SIZE = %d, IMAGE_SIZE = %d", SIZE, Math.pow(SIZE, MAX_DEPTH));
readGeoJSON(path.join(__dirname, "tz_world.json"), function(err, polygons) {
  if(err)
    throw err;

  var zones = tzindex(polygons);

  function tile(polygons, min_lat, min_lon, max_lat, max_lon, depth) {
    var box = [
          min_lon - MAX_DISTANCE_SQ,
          min_lat - MAX_DISTANCE_SQ,
          max_lon + MAX_DISTANCE_SQ,
          max_lat + MAX_DISTANCE_SQ
        ],
        list = [], i, data, x, y, lat, lon, best, dist, t, flat;

    for(i = polygons.length; i--; )
      if(polygons[i].overlap(box))
        list.push(polygons[i]);

    /* No polygons cover the area? Well then, just exit early. */
    if(list.length === 0)
      return 0xFFFF;

    /* Only one does? Then use it. (This isn't actually accurate, but our
     * compression is actually lossy. Furthermore, this just means that some
     * places will be considered land instead of ocean, which is actually
     * helpful for our use-case.) */
    if(list.length === 1)
      return zones.hash[list[0].tzid] | 0xFE00;

    /* If we don't want to recurse any more, just return a single pixel. */
    if(depth === MAX_DEPTH) {
      lat = (min_lat + max_lat) * 0.5;
      lon = (min_lon + max_lon) * 0.5;

      best = null;
      dist = MAX_DISTANCE_SQ;
      for(i = list.length; i--; ) {
        box[0] = lon - dist;
        box[1] = lat - dist;
        box[2] = lon + dist;
        box[3] = lat + dist;
        if(!list[i].overlap(box))
          continue;

        t = list[i].distance(lat, lon);
        if(t >= dist)
          continue;

        best = list[i];
        dist = t;
      }

      return best ? (zones.hash[best.tzid] | 0xFE00) : 0xFFFF;
    }

    /* Look up the entire tile. */
    data = new Array(SIZE * SIZE);
    flat = true;
    lat  = (max_lat - min_lat) / SIZE;
    lon  = (max_lon - min_lon) / SIZE;
    for(y = SIZE; y--; ) {
      for(x = SIZE; x--; ) {
        t = tile(
          list,
          min_lat + (SIZE - (y + 1)) * lat,
          min_lon + (x + 0) * lon,
          min_lat + (SIZE - (y + 0)) * lat,
          min_lon + (x + 1) * lon,
          depth + 1
        );

        data[y * SIZE + x] = t;

        if(typeof t !== "number")
          flat = false;
      }
    }

    /* Check to see if there's only one non-ocean color. If so, use it. If not,
     * if the only color is ocean, use that. Otherwise, I guess we have to
     * return the whole thing, oh well. */
    if(flat) {
      t = 0xFFFF;

      for(i = data.length; i--; ) {
        if(data[i] === 0xFFFF || data[i] === t)
          continue;

        if(t !== 0xFFFF)
          break;

        t = data[i];
      }

      if(i === -1)
        return t;
    }

    return {id: -1, data: data};
  }

  console.warn("TIMEZONE_LIST = %j", zones.list);
  write(tile(polygons, -90.0, -180.0, +90.0, +180.0, 0));
});
